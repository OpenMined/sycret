{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sycret documentation Python library for Function Secret Sharing with an efficient Rust backend using the AES-NI hardware acceleration. It is used in PySyft for ARIANN: Low-Interaction Privacy-Preserving Deep Learning via Function Secret Sharing . Installation pip install sycret Integration with PySyft The Python package is called from PySyft, like in this branch . Development instructions Structure src : the Rust crate. rustfss : the Python package calling the Rust crate with Maturin . tests : tests for the Rust crate. test : tests for the Python wrapper. Build Create a Python environment from dev-requirements.txt maturin develop -b cffi --release to build the crate, bind it to the Python package and install the package locally. Test cargo test to test the Rust functionality. pytest test to test the Python package. Publish docker run --rm --env RUSTFLAGS=\"-C target-feature=+aes,+ssse3\" -v $(pwd):/io konstin2/maturin publish -b cffi --manylinux 2010 -u __token__ -p pypi-your-token","title":"Sycret documentation"},{"location":"#sycret-documentation","text":"Python library for Function Secret Sharing with an efficient Rust backend using the AES-NI hardware acceleration. It is used in PySyft for ARIANN: Low-Interaction Privacy-Preserving Deep Learning via Function Secret Sharing .","title":"Sycret documentation"},{"location":"#installation","text":"pip install sycret","title":"Installation"},{"location":"#integration-with-pysyft","text":"The Python package is called from PySyft, like in this branch .","title":"Integration with PySyft"},{"location":"#development-instructions","text":"","title":"Development instructions"},{"location":"#structure","text":"src : the Rust crate. rustfss : the Python package calling the Rust crate with Maturin . tests : tests for the Rust crate. test : tests for the Python wrapper.","title":"Structure"},{"location":"#build","text":"Create a Python environment from dev-requirements.txt maturin develop -b cffi --release to build the crate, bind it to the Python package and install the package locally.","title":"Build"},{"location":"#test","text":"cargo test to test the Rust functionality. pytest test to test the Python package.","title":"Test"},{"location":"#publish","text":"docker run --rm --env RUSTFLAGS=\"-C target-feature=+aes,+ssse3\" -v $(pwd):/io konstin2/maturin publish -b cffi --manylinux 2010 -u __token__ -p pypi-your-token","title":"Publish"},{"location":"publish/","text":"Publish Package Test It is possible to test the publishing of a PyPI package with TestPyPI . In order to do this register an account if you haven't done so already and run the following: docker run --rm -v $(pwd):/io konstin2/maturin publish -b cffi --no-sdist -r https://test.pypi.org/legacy/ -u USERNAME -p PASSWORD --manylinux 2014 It's also possible to build a wheel for aarch as follows: Run docker container with: docker run --rm -it -v $(pwd):/home/rust/src messense/manylinux_2_24-cross:aarch64 Downloaded Rust tools via Rustup: curl https://sh.rustup.rs -sSf | bash -s -- -y Configured shell: echo 'source $HOME/.cargo/env' >> $HOME/.bashrc source $HOME/.cargo/env Added target: rustup target add aarch64-unknown-linux-gnu Publish package: maturin publish -b cffi --no-sdist -r https://test.pypi.org/legacy/ -u USERNAME -p PASSWORD --manylinux 2014 Production In order to do this manually for a production-ready release, one can do the same, without specifying the https://test.pypi.org/legacy/ URL. That is: docker run --rm -v $(pwd):/io konstin2/maturin publish -b cffi --no-sdist -u USERNAME -p PASSWORD --manylinux 2014 It's also possible to build a wheel for aarch as follows: Run docker container with: docker run --rm -it -v $(pwd):/home/rust/src messense/manylinux_2_24-cross:aarch64 Downloaded Rust tools via Rustup: curl https://sh.rustup.rs -sSf | bash -s -- -y Configured shell: echo 'source $HOME/.cargo/env' >> $HOME/.bashrc source $HOME/.cargo/env Added target: rustup target add aarch64-unknown-linux-gnu Publish package: maturin publish -b cffi --no-sdist -u USERNAME -p PASSWORD --manylinux 2014","title":"Publish Package"},{"location":"publish/#publish-package","text":"","title":"Publish Package"},{"location":"publish/#test","text":"It is possible to test the publishing of a PyPI package with TestPyPI . In order to do this register an account if you haven't done so already and run the following: docker run --rm -v $(pwd):/io konstin2/maturin publish -b cffi --no-sdist -r https://test.pypi.org/legacy/ -u USERNAME -p PASSWORD --manylinux 2014 It's also possible to build a wheel for aarch as follows: Run docker container with: docker run --rm -it -v $(pwd):/home/rust/src messense/manylinux_2_24-cross:aarch64 Downloaded Rust tools via Rustup: curl https://sh.rustup.rs -sSf | bash -s -- -y Configured shell: echo 'source $HOME/.cargo/env' >> $HOME/.bashrc source $HOME/.cargo/env Added target: rustup target add aarch64-unknown-linux-gnu Publish package: maturin publish -b cffi --no-sdist -r https://test.pypi.org/legacy/ -u USERNAME -p PASSWORD --manylinux 2014","title":"Test"},{"location":"publish/#production","text":"In order to do this manually for a production-ready release, one can do the same, without specifying the https://test.pypi.org/legacy/ URL. That is: docker run --rm -v $(pwd):/io konstin2/maturin publish -b cffi --no-sdist -u USERNAME -p PASSWORD --manylinux 2014 It's also possible to build a wheel for aarch as follows: Run docker container with: docker run --rm -it -v $(pwd):/home/rust/src messense/manylinux_2_24-cross:aarch64 Downloaded Rust tools via Rustup: curl https://sh.rustup.rs -sSf | bash -s -- -y Configured shell: echo 'source $HOME/.cargo/env' >> $HOME/.bashrc source $HOME/.cargo/env Added target: rustup target add aarch64-unknown-linux-gnu Publish package: maturin publish -b cffi --no-sdist -u USERNAME -p PASSWORD --manylinux 2014","title":"Production"},{"location":"python/","text":"Python API reference EqFactory Distributed Point Function. FSSFactory A generic class wrapping some constants and methods for FSS key generation and evaluation. __init__ ( self , key_len , n_threads = 0 , x_type =< class ' numpy . int64 '>, key_type=<class ' numpy . uint8 '>, result_type=<class ' numpy . int64 '>, N=4, L=16, lib_keygen=<cdata ' void ( * )( uint8_t * , uint8_t * , uintptr_t , uintptr_t , uintptr_t ) ' 0x7f0327580b30>, lib_eval=<cdata ' void ( * )( uintptr_t , uint8_t * , uint8_t * , int64_t * , uintptr_t , uintptr_t , uintptr_t ) ' 0x7f0327580e90>, op_id=1) special Initializes some constants for FSS. Parameters: Name Type Description Default key_len [type] [description] required n_threads int [description]. Defaults to 0. 0 x_type [type] [description]. Defaults to np.int64. <class 'numpy.int64'> key_type [type] [description]. Defaults to np.uint8. <class 'numpy.uint8'> result_type [type] [description]. Defaults to np.int64. <class 'numpy.int64'> N int [description]. Defaults to 4. 4 L int [description]. Defaults to 16. 16 lib_keygen [type] [description]. Defaults to lib.keygen. <cdata 'void(*)(uint8_t *, uint8_t *, uintptr_t, uintptr_t, uintptr_t)' 0x7f0327580b30> lib_eval [type] [description]. Defaults to lib.eval. <cdata 'void(*)(uintptr_t, uint8_t *, uint8_t *, int64_t *, uintptr_t, uintptr_t, uintptr_t)' 0x7f0327580e90> op_id int [description]. Defaults to 1. 1 Source code in sycret/fss.py def __init__ ( self , key_len , n_threads = 0 , x_type = np . int64 , key_type = np . uint8 , result_type = np . int64 , N = 4 , L = 16 , lib_keygen = lib . keygen , lib_eval = lib . eval , op_id = 1 , ): \"\"\"Initializes some constants for FSS. Args: key_len ([type]): [description] n_threads (int, optional): [description]. Defaults to 0. x_type ([type], optional): [description]. Defaults to np.int64. key_type ([type], optional): [description]. Defaults to np.uint8. result_type ([type], optional): [description]. Defaults to np.int64. N (int, optional): [description]. Defaults to 4. L (int, optional): [description]. Defaults to 16. lib_keygen ([type], optional): [description]. Defaults to lib.keygen. lib_eval ([type], optional): [description]. Defaults to lib.eval. op_id (int, optional): [description]. Defaults to 1. \"\"\" # NOTE: these defaults work for both equality and comparison, # but new primitives can override them if necessary. self . N = N self . L = L self . key_len = key_len self . x_type = x_type self . key_type = key_type self . result_type = result_type self . n_threads = n_threads self . lib_keygen = lib_keygen self . lib_eval = lib_eval self . op_id = op_id return alpha ( self , keys_a , keys_b ) Calculate the alpha value of the given key. Parameters: Name Type Description Default keys_a <built-in function array> Values of the first piece of the key required keys_b <built-in function array> Values of the second piece of the key required Returns: Type Description <built-in function array> Alpha values in an array Source code in sycret/fss.py def alpha ( self , keys_a : np . array , keys_b : np . array ) -> np . array : \"\"\"Calculate the alpha value of the given key. Arguments: keys_a: Values of the first piece of the key keys_b: Values of the second piece of the key Returns: Alpha values in an array \"\"\" key_values = ( lambda self , key : key [ 0 ][ 0 : self . N ] if key . shape [ 0 ] == 1 else np . ascontiguousarray ( key [:, 0 : self . N ]) ) alpha_a = np . frombuffer ( key_values ( self , keys_a ), dtype = np . uint32 ) alpha_b = np . frombuffer ( key_values ( self , keys_b ), dtype = np . uint32 ) alpha = alpha_a + alpha_b return alpha eval ( self , party_id , xs , keys , n_threads = 0 ) [summary] Parameters: Name Type Description Default party_id [type] [description] required xs [type] [description] required keys [type] [description] required n_threads int [description]. Defaults to 0. 0 Returns: Type Description [type] [description] Source code in sycret/fss.py def eval ( self , party_id , xs , keys , n_threads = 0 ): \"\"\"[summary] Args: party_id ([type]): [description] xs ([type]): [description] keys ([type]): [description] n_threads (int, optional): [description]. Defaults to 0. Returns: [type]: [description] \"\"\" n_values = xs . shape [ 0 ] results = np . zeros ( n_values , dtype = self . result_type ) # Warning: if the type is too big, the reshaping operation might be costly. np8_xs = np . ascontiguousarray ( xs . view ( dtype = np . uint8 ) . reshape ( n_values , - 1 )[:, 0 : self . N ] ) r_party_id = _as_usize ( party_id ) r_xs = _as_u8_array ( np8_xs ) r_keys = _as_u8_array ( keys ) r_results = _as_i64_array ( results ) r_n_values = _as_usize ( n_values ) r_n_threads = _as_usize ( n_threads ) r_op_id = _as_usize ( self . op_id ) # Call Rust on this memory. self . lib_eval ( r_party_id , r_xs , r_keys , r_results , r_n_values , r_n_threads , r_op_id ) return results keygen ( self , n_values = 1 ) [summary] Parameters: Name Type Description Default n_values int [description]. Defaults to 1. 1 Returns: Type Description [type] [description] Source code in sycret/fss.py def keygen ( self , n_values = 1 ): \"\"\"[summary] Args: n_values (int, optional): [description]. Defaults to 1. Returns: [type]: [description] \"\"\" # Allocate memory. keys_a = np . zeros (( n_values , self . key_len ), dtype = self . key_type ) keys_b = np . zeros (( n_values , self . key_len ), dtype = self . key_type ) # Convert types. r_keys_a = _as_u8_array ( keys_a ) r_keys_b = _as_u8_array ( keys_b ) r_n_values = _as_usize ( n_values ) r_n_threads = _as_usize ( self . n_threads ) r_op_id = _as_usize ( self . op_id ) # Call Rust on this memory. self . lib_keygen ( r_keys_a , r_keys_b , r_n_values , r_n_threads , r_op_id ) return keys_a , keys_b LeFactory Distributed Interval Functino.","title":"Python API reference"},{"location":"python/#python-api-reference","text":"","title":"Python API reference"},{"location":"python/#sycret.fss","text":"","title":"sycret.fss"},{"location":"python/#sycret.fss.EqFactory","text":"Distributed Point Function.","title":"EqFactory"},{"location":"python/#sycret.fss.FSSFactory","text":"A generic class wrapping some constants and methods for FSS key generation and evaluation.","title":"FSSFactory"},{"location":"python/#sycret.fss.FSSFactory.__init__","text":"Initializes some constants for FSS. Parameters: Name Type Description Default key_len [type] [description] required n_threads int [description]. Defaults to 0. 0 x_type [type] [description]. Defaults to np.int64. <class 'numpy.int64'> key_type [type] [description]. Defaults to np.uint8. <class 'numpy.uint8'> result_type [type] [description]. Defaults to np.int64. <class 'numpy.int64'> N int [description]. Defaults to 4. 4 L int [description]. Defaults to 16. 16 lib_keygen [type] [description]. Defaults to lib.keygen. <cdata 'void(*)(uint8_t *, uint8_t *, uintptr_t, uintptr_t, uintptr_t)' 0x7f0327580b30> lib_eval [type] [description]. Defaults to lib.eval. <cdata 'void(*)(uintptr_t, uint8_t *, uint8_t *, int64_t *, uintptr_t, uintptr_t, uintptr_t)' 0x7f0327580e90> op_id int [description]. Defaults to 1. 1 Source code in sycret/fss.py def __init__ ( self , key_len , n_threads = 0 , x_type = np . int64 , key_type = np . uint8 , result_type = np . int64 , N = 4 , L = 16 , lib_keygen = lib . keygen , lib_eval = lib . eval , op_id = 1 , ): \"\"\"Initializes some constants for FSS. Args: key_len ([type]): [description] n_threads (int, optional): [description]. Defaults to 0. x_type ([type], optional): [description]. Defaults to np.int64. key_type ([type], optional): [description]. Defaults to np.uint8. result_type ([type], optional): [description]. Defaults to np.int64. N (int, optional): [description]. Defaults to 4. L (int, optional): [description]. Defaults to 16. lib_keygen ([type], optional): [description]. Defaults to lib.keygen. lib_eval ([type], optional): [description]. Defaults to lib.eval. op_id (int, optional): [description]. Defaults to 1. \"\"\" # NOTE: these defaults work for both equality and comparison, # but new primitives can override them if necessary. self . N = N self . L = L self . key_len = key_len self . x_type = x_type self . key_type = key_type self . result_type = result_type self . n_threads = n_threads self . lib_keygen = lib_keygen self . lib_eval = lib_eval self . op_id = op_id return","title":"__init__()"},{"location":"python/#sycret.fss.FSSFactory.alpha","text":"Calculate the alpha value of the given key. Parameters: Name Type Description Default keys_a <built-in function array> Values of the first piece of the key required keys_b <built-in function array> Values of the second piece of the key required Returns: Type Description <built-in function array> Alpha values in an array Source code in sycret/fss.py def alpha ( self , keys_a : np . array , keys_b : np . array ) -> np . array : \"\"\"Calculate the alpha value of the given key. Arguments: keys_a: Values of the first piece of the key keys_b: Values of the second piece of the key Returns: Alpha values in an array \"\"\" key_values = ( lambda self , key : key [ 0 ][ 0 : self . N ] if key . shape [ 0 ] == 1 else np . ascontiguousarray ( key [:, 0 : self . N ]) ) alpha_a = np . frombuffer ( key_values ( self , keys_a ), dtype = np . uint32 ) alpha_b = np . frombuffer ( key_values ( self , keys_b ), dtype = np . uint32 ) alpha = alpha_a + alpha_b return alpha","title":"alpha()"},{"location":"python/#sycret.fss.FSSFactory.eval","text":"[summary] Parameters: Name Type Description Default party_id [type] [description] required xs [type] [description] required keys [type] [description] required n_threads int [description]. Defaults to 0. 0 Returns: Type Description [type] [description] Source code in sycret/fss.py def eval ( self , party_id , xs , keys , n_threads = 0 ): \"\"\"[summary] Args: party_id ([type]): [description] xs ([type]): [description] keys ([type]): [description] n_threads (int, optional): [description]. Defaults to 0. Returns: [type]: [description] \"\"\" n_values = xs . shape [ 0 ] results = np . zeros ( n_values , dtype = self . result_type ) # Warning: if the type is too big, the reshaping operation might be costly. np8_xs = np . ascontiguousarray ( xs . view ( dtype = np . uint8 ) . reshape ( n_values , - 1 )[:, 0 : self . N ] ) r_party_id = _as_usize ( party_id ) r_xs = _as_u8_array ( np8_xs ) r_keys = _as_u8_array ( keys ) r_results = _as_i64_array ( results ) r_n_values = _as_usize ( n_values ) r_n_threads = _as_usize ( n_threads ) r_op_id = _as_usize ( self . op_id ) # Call Rust on this memory. self . lib_eval ( r_party_id , r_xs , r_keys , r_results , r_n_values , r_n_threads , r_op_id ) return results","title":"eval()"},{"location":"python/#sycret.fss.FSSFactory.keygen","text":"[summary] Parameters: Name Type Description Default n_values int [description]. Defaults to 1. 1 Returns: Type Description [type] [description] Source code in sycret/fss.py def keygen ( self , n_values = 1 ): \"\"\"[summary] Args: n_values (int, optional): [description]. Defaults to 1. Returns: [type]: [description] \"\"\" # Allocate memory. keys_a = np . zeros (( n_values , self . key_len ), dtype = self . key_type ) keys_b = np . zeros (( n_values , self . key_len ), dtype = self . key_type ) # Convert types. r_keys_a = _as_u8_array ( keys_a ) r_keys_b = _as_u8_array ( keys_b ) r_n_values = _as_usize ( n_values ) r_n_threads = _as_usize ( self . n_threads ) r_op_id = _as_usize ( self . op_id ) # Call Rust on this memory. self . lib_keygen ( r_keys_a , r_keys_b , r_n_values , r_n_threads , r_op_id ) return keys_a , keys_b","title":"keygen()"},{"location":"python/#sycret.fss.LeFactory","text":"Distributed Interval Functino.","title":"LeFactory"},{"location":"rust/","text":"Rust API reference See the crate documentation on crates.io.","title":"Rust API reference"},{"location":"rust/#rust-api-reference","text":"See the crate documentation on crates.io.","title":"Rust API reference"}]}